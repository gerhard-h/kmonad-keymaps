;; hint shift and layer switch
;;(defalias
;;  oss (multi (one-shot 500 lsft) (one-shot 500 (layer-toggle customshiftlayer)))
;;)

;; y hold not used

;; where to put atx do it by layer flipping ... yes some how
 
;; one-shot lsft not working -> shiftlayer

 
;; (multi f24 sldr) has inconsistencies with sldr sldr not in use so far autohot key solution


;; if numtab is good make a key to flip remote desto controls dont work bc of timings


;; Exactly one defcfg entry is required. This is used for configuration key-pairs.
(defcfg
   sequence-timeout 3000
  ;; Windows doesn't need any input/output configuration entries; however, there
  ;; must still be a defcfg entry.
  ;;
  ;; There is an optional configuration entry for Windows to help mitigate strange
  ;; behaviour of AltGr if your layout uses that. Uncomment one of the items below
  ;; to change what kanata does with the key.
  ;;
  ;; For more context, see: https://github.com/jtroo/kanata/issues/55.
  ;;
  ;; windows-altgr cancel-lctl-press ;; remove the lctl press that comes as a combo with ralt  with F24 mapping
  ;; windows-altgr add-lctl-release  ;; add an lctl release when ralt is released           with standard Altgr 
  ;;
  ;; NOTE: even with these workarounds, putting lctl+ralt in your defsrc may
  ;; not work too well with other applications that use WH_KEYBOARD_LL.
  ;; Known applications with issues: GWSL/VcXsrv

  ;; Optional configuration: enable kanata to execute commands.
  ;;
  ;; I consider this feature a hazard so it is conditionally compiled out of
  ;; the default binary.
  ;;
  ;; This is dangerous because it allows kanata to execute arbitrary commands.
  ;; Using a binary compiled with the cmd feature enabled, uncomment below to
  ;; enable command execution:
  ;; danger-enable-cmd yes
)

;; Only one defsrc is allowed.
;;
;; defsrc defines the keys that will be intercepted by kanata. The order of the
;; keys matches the deflayer declarations and all deflayer declarations must
;; have the same number of keys as defsrc.
;;
;; The visual/spatial positioning is *not* mandatory; it is done by convention
;; for visual ease. These items are parsed as a long list with newlines being
;; ignored.
;;
;; If you are looking for other keys, the file src/keys/mod.rs should hopefully
;; provide some insight.


;; defsrc for iso german qwertz layout  
;; z and y are not flipped
;; positioning the /-key at the ansi or iso position both work
(defsrc

  \         1    2    3    4    5    6    7    8    9    0    [    ]    bspc
  tab       q    w    e    r    t    z    u    i    o    p    ;    =
  caps      a    s    d    f    g    h    j    k    l    grv  '    /    ret
  lsft 102d y    x    c    v    b    n    m    ,    .    -    rsft
  lctl      lmet lalt           spc                 f24  rmet rctl
)

;; The first layer defined is the layer that will be active by default when
;; kanata starts up.
;;
;; There are currently a maximum of 25 layers allowed.

;;          tapdance / hold symbols of the base layer s=shift c=ctrl a=alt
;;          1@   2    3    4    5    6    7    8    9    0 
;;          !    "    (    )    $    &    Ã¼    ?    Ã¶    \ 
;;          Ã¤    ÃŸ   c[   s]    '    /   s%    c   a#  
;;               |    {    }    +    =    *  ;<F24  :>  -_~
(deflayer qwerty
  @^        @1@  @2   @3`  @4   @5   @6   @7   @8    @9   @0   @sz  @os1  bspc
  @tab      @q!  @w'' @e   @r   @t$  @z&  @uÃ¼  @i?   @oÃ¶  @p\  bspc bspc
  @atx      @aÃ¤  @sÃŸ  @d[  @f]  @g'  @h/  @j%  @kC   @lA# bspc @rtw sldr  @rtw
  lsft  f24 @F23 @x|  @c{  @v}  @b+  @n=  @m*  @,F24 @.:> @-_~ @rsd
  lctl      lmet lalt           @mus                 f24  rmet @rcl 
)
;; SC06F remap altgr to f24 is not recognized by kanata
(deflayer upper
  @^         @1@  @2   @3`  @4   @5   @6   @7   @8    @9   @0   @sz  ]    bspc
  S-tab      S-q  S-w  S-e  S-r  S-t  S-z  S-u  S-i   S-o  S-p  bspc bspc
  caps       S-a  S-s  S-d  S-f  S-g  S-h  S-j  S-k   S-l  @sy1 @rtw sldr @rtw
  lsft S-102d S-y S-x  S-c  S-v  S-b  S-n  S-m  S-,   S-.  S--  rsft
  lctl       lmet lalt           @mus                 _    rmet rctl
)
(deflayer numbers
  _         @at1  @at2 @at3 @at4 @at5 @at6 @at7 @at8  @at9 @at0 lrld _    _     
  _         @-_~  1    @wn2 3    esc  esc  home up    end  pgup _    _     
  _         @.:>  @al4 @ct5 @sf6 @wn0 bspc left down  rght bspc _    _    _          
  _    @os1 @,F24 7    8    9    del  ret  tab  del   mrgt pgdn _               
  _         _     @sy1           _                         _    _    _          
)
(deflayer numberstab
  _         _    _    _    _    _    _    _    _    _    _    _    lrld _     
  _         @-_~ 1    @wn2 3    esc  esc  home up   end  pgup _    _     
  _         rght left rght rght @wn0 bspc left down rght bspc _    _    _          
  _   @os1 @,F24 7    8    9    del  ret  tab  del  mrgt pgdn _               
  _         _    @sy1           _                        _    _    _          
)
;;       ^  symbols layer (todo ÃŸ Ã¼ Ã¶ are mapped to duplicated symbols, - and _ are already on base layer)
;;          1    2    3    4    5    6    7    8    9    0 
;;          !    "    (    )    $    &    %    \    #    ?
;;          `    |    [    ]    '    /    %    _    #    -_
;;       ^  Â´    |    {    }    +    =    *    <    >    ~
(deflayer symbols
  _         _    _    _    _    _    _    _    _    _    _    _    _    _     
  _         S-1  S-2  S-8  S-9  S-4  S-6  S-5  S-[  /    @bsl _    _         
  _         @btk @pip @lsb @rsb S-/  S-7  S-5  S--  /    @-_~ _    _    _          
  _    @^   @tck @pip @lcb @rcb =    S-0  S-=  @lth @gth @til _               
  _         _    _              _                        _    _    _          
)
;; lsymbols and rsymbols are only usefull if activated by letter keys like v/n but I ditched that concept as to hard to do fast


;; Aliases are referred to by `@<alias_name>`. Aliases can refer to each other,
;; e.g. in the `anm` alias. However, an alias can only refer to another alias
;; that has been defined before it in the file.
(defalias

  ;; Aliases for layer "toggling". It's not quite toggling because the layer
  ;; will be active while the key is held and deactivated when the key is
  ;; released. An alternate action name you can use is layer-while-held.
  ;; However, the rest of this document will use The term "toggle" for brevity.
  ;; switch layer als possible
  num (layer-toggle numbers)
  numtab (layer-toggle numberstab)
  sym  (layer-toggle symbols)
  sy1  (one-shot 500 (layer-toggle symbols))
  os1 (one-shot 3000 (layer-toggle upper))
  ;; os1 (one-shot 500 lsft) not working
  ;; os1 (multi lsft (one-shot 500 (layer-toggle upper))) not working
  ;; os1 (tap-dance 140 lsft  (one-shot 500 (layer-toggle upper)) not working
  ;; tap-hold parameter order:

  ;; 1. tap timeout
  ;; 2. hold timeout
  ;; 3. tap action
  ;; 4. hold action
  ;;
  ;; The hold timeout is the number of milliseconds after which the hold action
  ;; will activate.
  ;;
  ;; The tap timeout is best explained in a roundabout way. When you press and
  ;; hold a standard key on your keyboard (e.g. 'a'), your operating system will
  ;; read that and keep sending 'a' to the active application. To be able to
  ;; replicate this behaviour with a tap-hold key, you must press-release-press
  ;; the key within the tap timeout window (number is milliseconds). Simply
  ;; holding the key results in the hold action activating, which is why you
  ;; need to double-press for the tap action to stay pressed.
  ;;
  ;; There are two additional versions of tap-hold available:
  ;; 1. tap-hold-press: if there is a key press, the hold action is activated
  ;; 2. tap-hold-release: if there is a press and release of another key, the
  ;; hold action is activated
  ;;
  ;; These versions are useful if you don't want to wait for the whole hold
  ;; timeout to activate, but want to activate the hold action immediately
  ;; based on the next key press or press and release of another key. These
  ;; versions might be great to implement home row mods.
  ;;
  ;; If you come from kmonad, tap-hold-press and tap-hold-release are similar
  ;; to tap-hold-next and tap-hold-next-release, respectively. If you know
  ;; the underlying keyberon crate, tap-hold-press is the HoldOnOtherKeyPress
  ;; and tap-hold-release is the PermissiveHold configuration.

  ;; alt tab
  at1 (multi lalt tab)
  at2 (multi lalt tab tab)
  at3 (multi lalt tab tab tab)
  at4 (multi lalt tab tab tab tab)
  at5 (multi lalt tab tab tab tab tab)
  at6 (multi lalt tab tab tab tab tab tab)
  at7 (multi lalt tab tab tab tab tab tab tab)
  at8 (multi lalt tab tab tab tab tab tab tab tab)
  at9 (multi lalt tab tab tab tab tab tab tab tab tab)
  ;;at0 (tap-dance 500 (@at1 @at2 @at3 @at4 @at5 @at6) )  ;; this does not work :(
  at0 (tap-dance 500 (A-tab (macro f24 r) (macro f24 t) (macro f24 z)) )
  aty (multi @numtab alt tab )
  atx (tap-hold 200 100 (multi alt tab) (multi @numtab alt tab tab) )
  
  ;; home row mods
  ;;f]  (tap-hold-release 140 140 f lsft)
  f]  (tap-dance 140 ((tap-hold-release 140 140 f lsft) (tap-hold 200 240 (macro f f) (macro A-C-9))))
  
  ;;j%  (tap-hold-release 140 140 j lsft)
  j%  (tap-dance 140 ((tap-hold-release 140 140 j lsft) (tap-hold 200 240 (macro j j) (macro S-5))))
  
  ;;d[  (tap-hold-release 200 240 d lctl)
  d[  (tap-dance 140 ((tap-hold-release 200 240 d lctl) (tap-hold 200 240 (macro d d) (macro A-C-8))))
  ;;kC  (tap-hold-release 200 240 k lctl) ;; left ctl resolves DITTO issues TODO retest
  ;;kC  (tap-dance 140 ((tap-hold-release 200 240 k lctl) (tap-hold 200 240 (macro k k) (macro - S-102d) ))) ;; todo somthing better than ->
  kC  (tap-dance 140 ((tap-hold-release 200 240 k lctl) (tap-hold 200 240 (macro k k) @aty ))) 
  ;;lA# (tap-hold-release 200 340 l alt)
  lA# (tap-dance 140 ((tap-hold-release 200 240 l alt) (tap-hold 200 240 (macro l l) (macro /) )))
  rtw (tap-hold-release 200 340 ret lmet)
  
  rsd (tap-hold-release 200 240 del rsft) ;; TODO not used ?!
  
  ;; number layer home row mods
  sf6 (tap-hold-release 200 240 6 lsft)
  ct5 (tap-hold-release 200 300 5 lctl)
  al4 (tap-hold-release 200 340 4 lalt)
  wn2 (tap-hold-release 200 240 2 rmet)
  wn0 (tap-hold-release 200 340 0 lmet)
  ;;ght (tap-hold-release 200 240 rght rmet)  ;;works

  
  ;; symbols
  bsl A-C-[							;; \
  rcb A-C-0							;; }
  lcb A-C-7   	                    ;; {
  rsb A-C-9							;; ]
  lsb A-C-8							;; [
  pip A-C-102d						;; |
  lth 102d							;; <
  gth S-102d						;; >
  til A-C-=			            	;; ~
  tck (macro ] spc )				;; Â´
  btk (macro S-] spc )				;; `
  ^   (macro \ spc )				;; ^
  tab (macro tab )

  1@ (tap-hold 140 140 1 (multi (macro S-1 ) (tap-hold 200 400 XX (macro bspc A-C-q ))) )  
  2 (tap-hold 200 300 2 (macro S-2 ))
  ;; 3` (tap-hold 200 300 3 @btk )
  ;; multi 3 3 because macro 3 3 is not working
  3` (tap-dance 140 ((tap-hold 10 100 3 (multi @btk (tap-hold 200 400 XX (macro S-] S-]))  ))  (tap-hold 10 100 (multi 3 3) (macro S-] S-] S-] spc))))
  4 (tap-hold 200 300 4 (macro S-4 ))
  5 (tap-hold 200 300 5 (macro S-5 ))
  6 (tap-hold 200 300 6 (multi (macro S-6 ) (tap-hold 200 400 XX (macro S-6 ))))
  7 (tap-hold 200 300 7 (multi (macro S-7 ) (tap-hold 200 400 XX (macro S-7 ))))
  8 (tap-hold 200 300 8 (multi (macro S-8 ) (tap-hold 200 400 XX (macro bspc A-C-8 ))) )
  9 (tap-hold 200 300 9 (macro S-9 ))
  ;;0 (tap-hold 200 300 0 (macro S-0 )
  0 (tap-hold 10 100 0 (multi (macro S-0 ) (tap-hold 200 400 XX (multi (macro S-0 ) (tap-hold 200 400 XX (macro S-0 ))  ))  ) )
  ;;sz (tap-hold 140 140 [ (tap-hold-release 200 300 (macro S-[ ) (macro A-C-[ )))
  sz (tap-hold 200 300 [ (multi (macro S-[ ) (tap-hold 200 500 XX (macro bspc A-C-[ ))))
 
  ;;! (unicode ! )
  ;;q! (tap-dance 140 ((tap-hold 10 100 q @!)  A-C-q))!u"u!Ã¼
  ;;q! (tap-dance 140 ((tap-hold 10 100 q S-1)  (tap-hold 10 100 (macro A-C-q) A-C-q)))
  ;;q! (tap-hold-press 140 140 q @!)          ;; !
  q! (tap-hold 140 140 q (multi (macro S-1 ) (tap-hold 200 400 XX (macro bspc A-C-q ))) )   ;; 1 @
  ;;q! (tap-dance 140 ((tap-hold 10 100 q @!) A-C-q sldr)) ;; tripple tap is not possible in timer
  w'' (tap-hold 140 140 w (macro S-2))          ;; "
  e  (tap-hold 140 140 e (macro S-8))           ;; (
  r  (tap-hold 140 140 r (multi (macro S-9 ) (tap-hold 200 400 XX (macro bspc A-C-q ))) )  ;; ) todo find a better use 
  t$  (tap-hold 140 140 t (macro S-4))          ;; $
  z&  (tap-hold 140 140 z (multi (macro S-6 ) (tap-hold 200 400 XX (macro S-6 ))))          ;; &
  ;;Ã¼ (unicode Ã¼)                                      ;; unicode does not allow shift for upper case
  ;; macro or tap-dance for anti key repeat
  uÃ¼  (tap-hold 140 140 u (multi (macro ; ) (tap-hold 400 400 XX (macro bspc S-5 ))) )		;; Ã¼ = ;  
  ;;uÃ¼  (tap-dance 100 ((tap-hold-press 10 100 u (macro ;))  (tap-hold 10 100 (macro u u) (macro S-5))))
  ;;p\  (tap-hold 200 200 i @bsl)                ;; \
  p\  (tap-dance 140 ((tap-hold 10 100 p (multi (macro @bsl ) (tap-hold 200 300 XX (macro @bsl ))))  (tap-hold 10 100 (macro p p) (macro @bsl @bsl) )))	
  ;;Ã¶ (unicode Ã¶)
  oÃ¶  (tap-hold 140 140 o (multi (macro grv ) (tap-hold 400 400 XX (macro bspc / ))) )	    ;; Ã¶ = grv #=/
  ;;oÃ¶  (tap-dance 140 ((tap-hold 10 100 o (macro grv))  (tap-hold 10 100 (macro o o) (macro /))))
  
  i?  (tap-hold 140 140 i (multi (macro S-[ ) (tap-hold 200 300 XX (macro S-[ ))))			                ;; ? = S-[
  ;;Ã¤ (unicode Ã¤)
  aÃ¤ (tap-hold 140 140 a (multi (macro ' ) (tap-hold 400 400 XX (macro bspc S-] spc ))))		;; Ã¤ = '  `=S-]
  ÃŸ (unicode ÃŸ)
  sÃŸ  (tap-hold 140 140 s @ÃŸ)			                ;; ÃŸ = [
  ;;sÃŸ  (tap-dance 100 ((tap-hold 200 100 s @ÃŸ)  (tap-hold 10 100 (macro s s) @pip)))
  g'  (tap-hold 140 140 g (macro S-/))  ;; '
  h/  (tap-hold 140 140 h (multi (macro S-7 ) (tap-hold 200 300 XX (macro S-7 ))) )          ;; / 
  
  x|  (tap-hold 140 140 x (multi (macro A-C-102d ) (tap-hold 200 300 XX (macro A-C-102d ))) )			;; |
  c{  (tap-hold 140 140 c (macro C-A-7))		;; {
  v}  (tap-hold 140 140 v (macro C-A-0))         ;; } @rsy
  ;; + (unicode +) unicode protects from accidental shifts and autorepeat but can't be used in macros
  b+  (tap-hold 140 140 b (multi (macro = ) (tap-hold 200 300 XX (macro = ))))			;; + = =  
  n=  (tap-hold 140 140 n (multi (macro S-0 ) (tap-hold 200 300 XX (multi (macro S-0 ) (tap-hold 200 400 XX (macro S-0 ))  ))) )          ;; = ==
  m*  (tap-hold 140 140 m (multi (macro S-= ) (tap-hold 200 300 XX (macro S-= S-= ))))			;; * *** = S-=
  ;;semi (unicode ;)
  ;;sem (tap-hold 140 140 , @semi)		;; ;
  ,F24 (tap-dance 140 ((tap-hold 10 100 , (multi (macro S-, ) (tap-hold 200 400 XX (macro bspc @lth ))) )  (tap-hold 10 100 f24 (macro @lth))))  ;; ,, = F24
  ;; : (unicode :)
  ;; dpp (tap-hold 140 140 . @:)	        ;; : S-.
  .:> (tap-dance 140 ((tap-hold 10 100 . (multi (macro S-. ) (tap-hold 200 400 XX (macro bspc @gth ))) )  (tap-hold 10 100 (macro . .) (macro @gth))))
  ;; uso (unicode _)
  ;; usc (tap-hold 140 140 - @uso)			;; _ S--
  -_~ (tap-dance 140 ((tap-hold 10 100 - (multi (macro S-- ) (tap-hold 200 400 XX (macro bspc @til ))) )  (tap-hold 10 100 (macro - -) (macro @til))))
  ;; mus (tap-dance 120 ((tap-hold  140 140 spc @num) (tap-hold  140 140 spc @sym) spc spc spc))  ;; DBL-tap-Hold is not realy good for the frequently used symbol layer
  mus (tap-hold  200 200 spc @num)
)
  
;;(defalias
  ;; For the multi action, all keys are pressed for the whole sequence
  ;; but still in the listed order which may be undesirable, particularly
  ;; for modifiers like shift. You probably want to use macro instead.
  ;;
  ;; Chording can be more succinctly described by the modifier prefixes
  ;; `C-`, `A-`, `S-`, and `M-` for lctrl, lalt, lshift, lmeta, but are possible
  ;; by using `multi` as well. The lmeta key is also known by some other
  ;; names: "Windows", "GUI", "Command", "Super".
  ;;
  ;; This use case for multi is typing an all-caps string.
 ;; alp (multi lsft a b c d e f g h i j k l m n o p q r s t u v w x y z)

  ;; Chords using the shortcut syntax. These ones are used for copying/pasting
  ;; from some Linux terminals.
 ;; csv C-S-v
 ;; csc C-S-c

  ;; Windows shortcut for displaying all windows
 ;; win M-tab

  ;; macro accepts keys, chords, and numbers (a delay in ms). Note that numbers
  ;; will be parsed as delays, so they will need to be aliased to be used.
  ;; lch (macro h t t p @: / / 100 l o c a l h o s t @: @8 @0 @8 @0)

  ;; unicode accepts a single unicode character. The unicode character will
  ;; not be automatically repeated by holding the key down. The alias name
  ;; is the unicode character itself and is referenced by @ðŸ™ in deflayer.
 ;; ðŸ™ (unicode ðŸ™)

  ;; Having a cmd action in your configuration without explicitly enabling
  ;; `danger-enable-cmd` **and** using the cmd-enabled executable will make
  ;; kanata refuse to load your configuration. The aliases below are commented
  ;; out since commands aren't allowed by this configuration file.
  ;;
  ;; Note that the parameters to `cmd` are executed directly as opposed to
  ;; passed to a shell. So for example, `~` and `$HOME` would not refer
  ;; to your home directory on Linux.
  ;;
  ;; You can use:
  ;; `cmd bash -c "your_stuff_here"` to run your command inside of bash.
  ;;
  ;; cm1 (cmd bash -c "echo hello world")
  ;; cm2 (cmd rm -fr /tmp/testing)
 ;; )

;; The underscore _ means transparent. The key on the base layer will be used
;; instead. XX means no-op. The key will do nothing.
;; (deflayer numbers
;;   _    _    _    _    _    _    nlk  kp7  kp8  kp9  _    _    _    _
;;   _    _    _    _    _    XX   _    kp4  kp5  kp6  -    _    _    _
;;   _    _    C-z  _    _    XX   _    kp1  kp2  kp3  +    _    _
;;   _  _ C-z  C-x  C-c  C-v  XX   _    kp0  kp0  .    /    _
;;   _    _    _              _              _    _    _
;; )

;; The `lrld` action stands for "live reload". This will re-parse everything
;; except for linux-dev. So in Linux, you cannot live reload and switch keyboard
;; devices at the time of writing.
;;
;; Upon a successful reload, the kanata state will begin on the default base layer
;; in the configuration. E.g. in this example configuration, you would start on
;; the qwerty layer.
;;
;; WARNING: live reload leaks memory. This should not be a major problem though.
;; Here are the measurements of memory consumption on Windows for version 1.0.0:
;; - 20 reloads: 15.4 MB memory consumed
;; - 50 reloads: 20.4 MB memory consumed
;; So about 170 KB used per live reload. You'll probably be fine.
;;
;; Note: version 1.0.3 has probably doubled the amount of memory leaked per
;; reload, though it has not been measured. In practice it's still negligible
;; compared to a browser for example.
;; (deflayer layers
;;   _    @qwr _    lrld _    _    _    _    _    _    _    _    _    _
;;   _    _    _    _    _    _    _    _    _    _    _    _    _    _
;;   _    _    _    _    _    _    _    _    _    _    _    _    _
;;   _  _ _    _    _    _    _    _    _    _    _    _    _
;;   _    _    _              _              _    _    _
;; )

;;(defalias
  ;; Alias for one-shot which will activate an action until either the timeout
  ;; expires or a different key is pressed. The timeout is the first parameter
  ;; and the action is the second parameter.
  ;;
  ;; The intended use cases are pressing a modifier for exactly one key or
  ;; switching to another layer for exactly one key.
  ;;
  ;; If a one-shot key is held then it will act as a regular key. E.g. for os1
  ;; below, holding an @os1 key will keep lsft held and holding an @os3 key
  ;; will keep the layer set to misc.
 ;; os1 (one-shot 500 lsft)
 ;; os2 (one-shot 500 C-S-lalt)
 ;; os3 (one-shot 500 (layer-toggle misc))

  ;; Alias for tap-dance which will activate one of the actions in the action
  ;; list depending on how many taps were done. Tapping once will output the
  ;; first action and tapping N times will output the N'th action.
  ;;
  ;; The first parameter is a timeout. Tapping the same tap-dance key again
  ;; within the timeout will reset the timeout and advance the tap-dance to the
  ;; next key.
  ;;
  ;; The action activates either when any of the following happens:
  ;; - the timeout expires
  ;; - the tap sequence reaches the end
  ;; - a different key is pressed
;;  td (tap-dance 200 (a b c d spc))
;;)

;;(deflayer arrows
;;  _    f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12  _
;;  _    _    _    _    _    _    _    pgup up   pgdn _    _    _    _
;;  _    _    _    _    _    _    home left down rght end  _    _
;;  _  _ _    _    _    _    _    _    _    _    _    _    _
;;  _    _    _              _                  _    _
;;)

;; In Windows, using mouse buttons on the kanata window seems to cause it to hang.
;; Using the mouse on other windows seems to be fine though.
;;
;; The mouse buttons can be clicked using mlft, mrgt and mmid, representing the
;; left, right, and middle mouse buttons respectively. If the key is held, the
;; button press will also be held.
;;
;; If there are multiple mouse click actions within a single multi action, e.g.
;; (multi mrgt mlft), then all the buttons except the last will be clicked then
;; unclicked. The last button will remain held until key release. In the example
;; given, the button sequence will be:
;; press key->click right->unclick right->click left->release key->release left
;;
;; There are variants of the standard mouse buttons which "tap" the button.
;; These are mltp, mrtp, and mmtp. Rather than holding until key release, this
;; action will click and unclick the button once the key is pressed. Nothing
;; happens on key release. The action (multi lctl mltp) will result in the
;; sequence below:
;; press key->press lctl->click left->unclick left->release key->release lctl
;;(deflayer mouse
;;  _    @mwu @mwd @mwl @mwr _    _    _    _    _    _    _    _    _
;;  _    pgup bck  _    fwd  _    _    _    _    _    _    _    _    _
;;  _    pgdn mlft _    mrgt mmid _    _    _    _    _    _    _
;;  _ _  _    mltp _    mrtp mmtp _    _    _    _    _    _
;;  _    _    _              _                 _    _
;;)

;; (defalias
;;   ;; Mouse wheel actions. The first number is the interval in milliseconds
;;   ;; between scroll actions. The second number is the distance in some arbitrary
;;   ;; unit. Play with the parameters to see what feels correct. Both numbers
;;   ;; must be in the range 1-65535
;;   ;;
;;   ;; In both Windows and Linux, 120 distance units is equivalent to a single
;;   ;; notch movement on a physical wheel. In Linux, not all desktop environments
;;   ;; support the REL_WHEEL_HI_RES event so kanata just doesn't use it; instead a
;;   ;; scroll happens if 120 or more distance units are accumulated. This may result
;;   ;; in poor scrolling experience so in Linux it is recommended to use a distance
;;   ;; value that is a multiple of 120.
;;   mwu (mwheel-up 50 120)
;;   mwd (mwheel-down 50 120)
;; 
;;   ;; Horizontal mouse wheel actions. Similar story to vertical mouse wheel.
;;   mwl (mwheel-left 50 120)
;;   mwr (mwheel-right 50 120)
;; )
;; FAKE KEYS
 ;; (defalias
 ;;   lft (multi (release-key ralt) left) ;; release ralt if held and also press left
 ;;   rgt (multi (release-key ralt) rght) ;; release ralt if held and also press rght
 ;;   rlr (release-layer ralted)          ;; release layer-toggle of ralted
 ;; )

;; Press and release fake keys.
;;
;; Fake keys can't be pressed by any physical keyboard buttons and can only be
;; acted upon by the actions on-press-fakekey and on-release-fakekey. The
;; purpose of fake keys is for a use case such as holding modifier keys for
;; any number of keypresses and then releasing the modifiers when desired.
;;
;; The actions associated with fake keys in deffakekeys are parsed before
;; aliases, so you can't use aliases within deffakekeys. Other than the lack
;; of alias support, fake keys can do any action that a normal key can,
;; including doing operations on previously defined fake keys.
;;
;; Operations on fake keys can occur either on press (on-press-fakekey or
;; on release (on-release-fakekey The use cases for the on-release variant
;; are left up to your own creativity.
;; (deflayer fakekeys
;;   _    @fcp @fsp @fmp @pal _    _    _    _    _    _    _    _    _
;;   _    @fcr @fsr @fap @ral _    _    _    _    _    _    _    _    _
;;   _    @fct @fst @rma _    _    _    _    _    _    _    _    _
;;   _ _  _    _    _    _    _    _    _    _    _    _    _
;;   _    _    _              _                  _    _
;; )

(deffakekeys
  ctl lctl
  sft lsft
  lsft lsft
  met lmet
  alt lalt
  mmid mmid
  pal (multi
        (on-press-fakekey ctl press)
        (on-press-fakekey sft press)
        (on-press-fakekey met press)
        (on-press-fakekey alt press)
      )
  ral (multi
        (on-press-fakekey ctl release)
        (on-press-fakekey sft release)
        (on-press-fakekey met release)
        (on-press-fakekey alt release)
      )
)

(defalias
  fcp (on-press-fakekey ctl press)
  fcr (on-press-fakekey ctl release)
  fct (on-press-fakekey ctl tap)
  fsp (on-release-fakekey sft press)
  fsr (on-release-fakekey sft release)
  fst (on-release-fakekey sft tap)
  fmp (on-press-fakekey met press)
  fap (on-press-fakekey alt press)
  far (on-press-fakekey alt release)
  rma (multi
        (on-press-fakekey met release)
        (on-press-fakekey alt release)
      )
  pal (on-press-fakekey pal tap)
  ral (on-press-fakekey ral tap)

  ;; If you find that an application isn't registering keypresses correctly
  ;; with multi, you can try out:
  ;; - on-press-fakekey-delay
  ;; - on-release-fakekey-delay
  ;;
  ;; Do note that processing a fakekey-delay and even a sequence of delays will
  ;; delay any other inputs from being processed until the fakekey-delays are
  ;; all complete, so use with care.
  stm (multi ;; Shift -> middle mouse with a delay
    (on-press-fakekey lsft press)
    (on-press-fakekey-delay 200)
    (on-press-fakekey mmid press)
    (on-release-fakekey mmid release)
    (on-release-fakekey-delay 200)
    (on-release-fakekey lsft release)
  )
)

;; Vim-style leader-key sequences. Activate a fakekey-tap by pressing a "leader"
;; key and then a sequence of characters.
;; See: https://github.com/jtroo/kanata/issues/97
;;
;; You can add an entry to defcfg to change the sequence timeout (default is 1000):
;;     sequence-timeout <number(ms)>
(defseq git-status (g s t))
(deffakekeys git-status (macro g i t spc s t a t u s ret))

(defseq web-de (w e))
(deffakekeys web-de (macro g e r h a r d . h e i d e A-C-q w e b . d e))

;; f24 macros dont work ?
(defseq web-def (f24 w e))
(deffakekeys web-def (macro g e r h a r d . h e i d e A-C-q w e b . d e))

(defseq str (s t))
(defseq ded (d e))
(defseq wic (w i))
(defseq wal (w a))
(defseq mar (m a))
(defseq m'  (m '))
(defseq flo (f l))
(defseq seb (s e))
(defseq jar (j a))
(defseq mon (m o))
(defseq mfg (m f))
(defseq bye (b y))
(defseq msg (m s))
(defseq dih (d i))
(defseq iba (i b))
(defseq z1  (1))
(defseq z2  (2))
(defseq iba (3))

;; deffakekeys with S- uppercase defsrc keys spc A-C-q and kp1-kp9

(deffakekeys str (macro S-h  a l l o spc  S-h  e r r spc   S-s  t r e c k e r t , ret ret ))
(deffakekeys ded (macro S-h  a l l o spc  S-h  e r r spc  S-d  e d e r i c h s , ret ret ))
(deffakekeys wic (macro S-h  a l l o spc  S-h  e r r spc   S-w  i c k l m a y r , ret ret ))
(deffakekeys wal (macro S-h  a l l o spc  S-f  r a u spc   S-w  a l d e n m a i e r , ret ret ))
(deffakekeys mar (macro S-h  a l l o spc  S-m  a r k u s , ret ret ))
(deffakekeys m'  (macro S-h  a l l o spc  S-f  r a u spc   S-m  ' d e r , ret ret ))
(deffakekeys flo (macro S-h  a l l o spc  S-f  l o r i a n , ret ret ))
(deffakekeys seb (macro S-h  a l l o spc  S-s  e b a s t i a n , ret ret ))
(deffakekeys jar (macro S-h  a l l o spc  S-h  e r r  spc  S-j  a r o s c h , ret ret ))
(deffakekeys mon (macro S-h  a l l o spc  S-m  o n i k a , ret ret ))
(deffakekeys mfg (macro S-m  i t spc   f r e u n d l i c h e n spc  S-g  r ; [ e n   spc ret  S-g  e r h a r d spc  S-h  e i d e ))
(deffakekeys bye (macro b y e ret S-g  e r h a r d ))
(deffakekeys msg (macro g e r h a r d . h e i d e A-C-q m s g . g r o u p ))
(deffakekeys dih (macro S-d  - S-s  S-m  S-y  S-q  - S-i  kp7 S-m  S-y  S-d  - kp7 kp5 ))
(deffakekeys iba (macro S-d  S-e  kp3 kp0 kp7 kp0 kp0 kp2 kp0 kp2 kp7 kp0 kp0 kp0 kp4 kp5 kp5 kp0 kp6 kp8 kp6 kp0 ))
(deffakekeys z1 (macro kp1 kp1 . kp1 kp1 . kp2 kp0 kp2 kp2 ))
(deffakekeys z2 (macro kp2 kp1 . kp1 kp2 . kp2 kp0 kp0 kp1 ))

(defalias
 rcl (tap-hold-release 200 200 sldr rctl) ;; !! sldr is hard coded leader key fake key  !!
 rwi (tap-hold-release 200 200 sldr rmet)
 ;; F23 (tap-hold 200 200 y (multi f24 sldr))  ;; works technically f24 triggers y itselft if  must be hold for f24 ... feels bad
 F23 (tap-hold-release 200 200 y f23)  
)